{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _find from \"lodash/find\";\nimport _isEqual from \"lodash/isEqual\";\nimport _has from \"lodash/has\";\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { shallowEqual, getDisplayName, removeEmptyKey } from './utils';\n/**\n * @typedef {object} ConnectorDescription\n * @property {string} displayName - the displayName used by the wrapper\n * @property {function} refine - a function to filter the local state\n * @property {function} getSearchParameters - function transforming the local state to a SearchParameters\n * @property {function} getMetadata - metadata of the widget\n * @property {function} transitionState - hook after the state has changed\n * @property {function} getProvidedProps - transform the state into props passed to the wrapped component.\n * Receives (props, widgetStates, searchState, metadata) and returns the local state.\n * @property {function} getId - Receives props and return the id that will be used to identify the widget\n * @property {function} cleanUp - hook when the widget will unmount. Receives (props, searchState) and return a cleaned state.\n * @property {object} propTypes - PropTypes forwarded to the wrapped component.\n * @property {object} defaultProps - default values for the props\n */\n\n/**\n * Connectors are the HOC used to transform React components\n * into InstantSearch widgets.\n * In order to simplify the construction of such connectors\n * `createConnector` takes a description and transform it into\n * a connector.\n * @param {ConnectorDescription} connectorDesc the description of the connector\n * @return {Connector} a function that wraps a component into\n * an instantsearch connected one.\n */\n\nexport default function createConnector(connectorDesc) {\n  if (!connectorDesc.displayName) {\n    throw new Error('`createConnector` requires you to provide a `displayName` property.');\n  }\n\n  var hasRefine = _has(connectorDesc, 'refine');\n\n  var hasSearchForFacetValues = _has(connectorDesc, 'searchForFacetValues');\n\n  var hasSearchParameters = _has(connectorDesc, 'getSearchParameters');\n\n  var hasMetadata = _has(connectorDesc, 'getMetadata');\n\n  var hasTransitionState = _has(connectorDesc, 'transitionState');\n\n  var hasCleanUp = _has(connectorDesc, 'cleanUp');\n\n  var hasShouldComponentUpdate = _has(connectorDesc, 'shouldComponentUpdate');\n\n  var isWidget = hasSearchParameters || hasMetadata || hasTransitionState;\n  return function (Composed) {\n    var _class, _temp;\n\n    return _temp = _class =\n    /*#__PURE__*/\n    function (_Component) {\n      _inherits(Connector, _Component);\n\n      function Connector() {\n        var _getPrototypeOf2;\n\n        var _this;\n\n        _classCallCheck(this, Connector);\n\n        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n          _args[_key] = arguments[_key];\n        }\n\n        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Connector)).call.apply(_getPrototypeOf2, [this].concat(_args)));\n\n        _defineProperty(_assertThisInitialized(_this), \"mounted\", false);\n\n        _defineProperty(_assertThisInitialized(_this), \"unmounting\", false);\n\n        _defineProperty(_assertThisInitialized(_this), \"refine\", function () {\n          var _connectorDesc$refine;\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          _this.context.ais.onInternalStateUpdate((_connectorDesc$refine = connectorDesc.refine).call.apply(_connectorDesc$refine, [_assertThisInitialized(_this), _this.props, _this.context.ais.store.getState().widgets].concat(args)));\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"createURL\", function () {\n          var _connectorDesc$refine2;\n\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          return _this.context.ais.createHrefForState((_connectorDesc$refine2 = connectorDesc.refine).call.apply(_connectorDesc$refine2, [_assertThisInitialized(_this), _this.props, _this.context.ais.store.getState().widgets].concat(args)));\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"searchForFacetValues\", function () {\n          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            args[_key4] = arguments[_key4];\n          }\n\n          _this.context.ais.onSearchForFacetValues(connectorDesc.searchForFacetValues.apply(connectorDesc, [_this.props, _this.context.ais.store.getState().widgets].concat(args)));\n        });\n\n        _this.state = {\n          props: _this.getProvidedProps(_objectSpread({}, _this.props, {\n            // @MAJOR: We cannot drop this beacuse it's a breaking change. The\n            // prop is provided to `createConnector.getProvidedProps`. All the\n            // custom connectors are impacted by this change. It should be fine\n            // to drop it in the next major though.\n            canRender: false\n          }))\n        };\n\n        if (process.env.NODE_ENV === 'development') {\n          var onlyGetProvidedPropsUsage = !_find(Object.keys(connectorDesc), function (key) {\n            return ['getMetadata', 'getSearchParameters', 'refine', 'cleanUp'].indexOf(key) > -1;\n          });\n\n          if (onlyGetProvidedPropsUsage && connectorDesc.displayName.substr(0, 7) !== 'Algolia') {\n            // eslint-disable-next-line no-console\n            console.warn('react-instantsearch: it seems that you are using the `createConnector` api ' + 'only to access the `searchState` and the `searchResults` through `getProvidedProps`.' + 'We are now provided a dedicated API' + ' the `connectStateResults` connector that you should use instead. The `createConnector` API will be ' + 'soon deprecated and will break in future next major versions.' + '\\n\\n' + 'See more at https://www.algolia.com/doc/api-reference/widgets/state-results/react/' + '\\n' + 'and https://www.algolia.com/doc/guides/building-search-ui/going-further/conditional-display/react/');\n          }\n        }\n\n        return _this;\n      }\n\n      _createClass(Connector, [{\n        key: \"componentWillMount\",\n        value: function componentWillMount() {\n          if (connectorDesc.getSearchParameters) {\n            this.context.ais.onSearchParameters(connectorDesc.getSearchParameters.bind(this), this.context, this.props);\n          }\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          var _this2 = this;\n\n          this.mounted = true;\n          this.unsubscribe = this.context.ais.store.subscribe(function () {\n            if (!_this2.unmounting) {\n              _this2.setState({\n                props: _this2.getProvidedProps(_objectSpread({}, _this2.props, {\n                  // @MAJOR: see constructor\n                  canRender: true\n                }))\n              });\n            }\n          });\n\n          if (isWidget) {\n            this.unregisterWidget = this.context.ais.widgetsManager.registerWidget(this);\n          }\n        }\n      }, {\n        key: \"componentWillReceiveProps\",\n        value: function componentWillReceiveProps(nextProps) {\n          if (!_isEqual(this.props, nextProps)) {\n            this.setState({\n              props: this.getProvidedProps(_objectSpread({}, nextProps, {\n                // @MAJOR: see constructor\n                canRender: this.mounted\n              }))\n            });\n\n            if (isWidget) {\n              this.context.ais.widgetsManager.update();\n\n              if (connectorDesc.transitionState) {\n                this.context.ais.onSearchStateChange(connectorDesc.transitionState.call(this, nextProps, this.context.ais.store.getState().widgets, this.context.ais.store.getState().widgets));\n              }\n            }\n          }\n        }\n      }, {\n        key: \"shouldComponentUpdate\",\n        value: function shouldComponentUpdate(nextProps, nextState) {\n          if (hasShouldComponentUpdate) {\n            return connectorDesc.shouldComponentUpdate.call(this, this.props, nextProps, this.state, nextState);\n          }\n\n          var propsEqual = shallowEqual(this.props, nextProps);\n\n          if (this.state.props === null || nextState.props === null) {\n            if (this.state.props === nextState.props) {\n              return !propsEqual;\n            }\n\n            return true;\n          }\n\n          return !propsEqual || !shallowEqual(this.state.props, nextState.props);\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.unmounting = true;\n\n          if (this.unsubscribe) {\n            this.unsubscribe();\n          }\n\n          if (this.unregisterWidget) {\n            this.unregisterWidget();\n\n            if (hasCleanUp) {\n              var nextState = connectorDesc.cleanUp.call(this, this.props, this.context.ais.store.getState().widgets);\n              this.context.ais.store.setState(_objectSpread({}, this.context.ais.store.getState(), {\n                widgets: nextState\n              }));\n              this.context.ais.onSearchStateChange(removeEmptyKey(nextState));\n            }\n          }\n        }\n      }, {\n        key: \"getProvidedProps\",\n        value: function getProvidedProps(props) {\n          var _this$context$ais$sto = this.context.ais.store.getState(),\n              widgets = _this$context$ais$sto.widgets,\n              results = _this$context$ais$sto.results,\n              resultsFacetValues = _this$context$ais$sto.resultsFacetValues,\n              searching = _this$context$ais$sto.searching,\n              searchingForFacetValues = _this$context$ais$sto.searchingForFacetValues,\n              isSearchStalled = _this$context$ais$sto.isSearchStalled,\n              metadata = _this$context$ais$sto.metadata,\n              error = _this$context$ais$sto.error;\n\n          var searchResults = {\n            results: results,\n            searching: searching,\n            searchingForFacetValues: searchingForFacetValues,\n            isSearchStalled: isSearchStalled,\n            error: error\n          };\n          return connectorDesc.getProvidedProps.call(this, props, widgets, searchResults, metadata, // @MAJOR: move this attribute on the `searchResults` it doesn't\n          // makes sense to have it into a separate argument. The search\n          // flags are on the object why not the resutls?\n          resultsFacetValues);\n        }\n      }, {\n        key: \"getSearchParameters\",\n        value: function getSearchParameters(searchParameters) {\n          if (hasSearchParameters) {\n            return connectorDesc.getSearchParameters.call(this, searchParameters, this.props, this.context.ais.store.getState().widgets);\n          }\n\n          return null;\n        }\n      }, {\n        key: \"getMetadata\",\n        value: function getMetadata(nextWidgetsState) {\n          if (hasMetadata) {\n            return connectorDesc.getMetadata.call(this, this.props, nextWidgetsState);\n          }\n\n          return {};\n        }\n      }, {\n        key: \"transitionState\",\n        value: function transitionState(prevWidgetsState, nextWidgetsState) {\n          if (hasTransitionState) {\n            return connectorDesc.transitionState.call(this, this.props, prevWidgetsState, nextWidgetsState);\n          }\n\n          return nextWidgetsState;\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          if (this.state.props === null) {\n            return null;\n          }\n\n          var refineProps = hasRefine ? {\n            refine: this.refine,\n            createURL: this.createURL\n          } : {};\n          var searchForFacetValuesProps = hasSearchForFacetValues ? {\n            searchForItems: this.searchForFacetValues\n          } : {};\n          return React.createElement(Composed, _extends({}, this.props, this.state.props, refineProps, searchForFacetValuesProps));\n        }\n      }]);\n\n      return Connector;\n    }(Component), _defineProperty(_class, \"displayName\", \"\".concat(connectorDesc.displayName, \"(\").concat(getDisplayName(Composed), \")\")), _defineProperty(_class, \"defaultClassNames\", Composed.defaultClassNames), _defineProperty(_class, \"propTypes\", connectorDesc.propTypes), _defineProperty(_class, \"defaultProps\", connectorDesc.defaultProps), _defineProperty(_class, \"contextTypes\", {\n      // @TODO: more precise state manager propType\n      ais: PropTypes.object.isRequired,\n      multiIndexContext: PropTypes.object\n    }), _temp;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}